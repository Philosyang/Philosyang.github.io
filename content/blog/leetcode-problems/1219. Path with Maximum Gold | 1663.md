---
title: "1219. Path with Maximum Gold | 1663"
date: 2025-11-23
tags: ["array", "matrix", "backtracking", "python", "revisit"]
---

Very meaningful one for bfs enjoyers - why using bfs is such a bad idea for some questions.  
Also practices on backtracking.

```python
class Solution:
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        # intuition:
        # bfs from every cell that's not 0
        # keep a global max, which is the answer
        # keep a visited set() for each bfs

        # BFS does not work easily.
        # example:
        # [1,2,3],
        # [2,0,4],
        # [7,6,5],
        # [8,0,6],
        # [9,8,7]
        # one possible solution: 2-1-2-3-4-5-6-7-8-9-8-7-6
        # why BFS fails:
        # 2-7-6-5
        # 2-1-2-3-4-dead

        # NOTE: BFS with a single `visited` set per start is incorrect here.
        # "Visited" is per *path*, not per *cell*:
        # two different paths can end at the same cell but have visited
        # different other cells before it. A BFS that only stores (r, c)
        # and a global `visited` set will merge those states and prune
        # valid paths. DFS + backtracking is a natural fit because each
        # recursive call has its own visited history (via mark/unmark).

        result = 0
        m, n = len(grid), len(grid[0])

        def dfs(loc, gold, visited):
            x, y = loc

            if (
                loc in visited
                or x < 0
                or x > m - 1
                or y < 0
                or y > n - 1
                or grid[x][y] == 0
            ):
                return gold

            gold += grid[x][y]

            visited.add(loc)
            best = max(
                dfs((x, y + 1), gold, visited),
                dfs((x + 1, y), gold, visited),
                dfs((x, y - 1), gold, visited),
                dfs((x - 1, y), gold, visited),
            )
            visited.remove(loc)

            return best

        for x in range(m):
            for y in range(n):
                possibility = dfs((x, y), 0, set())
                if possibility > result:
                    result = possibility

        return result
```

todo: there could be a cleaner one that does not need to carry gold around