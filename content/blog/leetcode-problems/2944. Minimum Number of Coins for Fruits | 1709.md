---
title: "2944. Minimum Number of Coins for Fruits | 1709"
date: 2025-12-22
tags: ["array", "dynamic-programming", "python"]
---

backtrack + memoization -> top-down DP.

Had to consult some hint to figure out the state, but I will gladly take it as a backtrack practice and a tap into DP.

```python
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        # intuition: backtrack
        # 1. purchase this fruit
        # 2. take for free (if possible)
        # need memoization

        # how to turn backtrack into DP:
        # Backtracking = “try choices from a position”
        # DP = “notice you revisit the same situation; cache it”
        # So the whole game is: define “same situation” = your **state**.

        n = len(prices)

        @lru_cache(None)
        def dfs(pos, free_end):
            if pos > n:  # OB
                return 0
            if pos > free_end:  # have to pay
                return prices[pos - 1] + dfs(pos + 1, max(2 * pos, free_end))
            else:  # can take free
                return min(
                    dfs(pos + 1, free_end),
                    prices[pos - 1] + dfs(pos + 1, max(2 * pos, free_end)),
                )

        return dfs(0, 0)
```