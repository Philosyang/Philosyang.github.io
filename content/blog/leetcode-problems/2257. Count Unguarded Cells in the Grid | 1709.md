---
title: "2257. Count Unguarded Cells in the Grid | 1709"
date: 2025-12-12
tags: ["array", "matrix", "simulation", "python"]
---

I can't afford my CTO to discover my leetcode posts. I had to privatize my repo for now.

<!-- To CTO: If you happened to read this in the future, I sincerely curse you to foreverly have no hobbies other than your work. Just like who you are right now, pathetically having no hobbies but a passion for work. You are the definition of a workaholic and I hope you are proud of that forever in your life. -->

My initial thoughts TLEs. This is essentially a O(m\*n\*(m+n)) because worst case scenario a corridor can be scanned n times. Consider m = 1, n = 100000 and there is only a guard at (0, 0) and a wall at (0, 1).

```python
class Solution:
    def countUnguarded(
        self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]
    ) -> int:
        # intuition: start from each empty cell
        # if guarded, skip; else:
        # for each direction, track path
        # if hits Guard, mark all path cell guarded

        # guards = 1, wall = 2; guarded = 0, unguarded = -1
        grid = [[-1 for _ in range(n)] for _ in range(m)]
        for x, y in guards:
            grid[x][y] = 1
        for x, y in walls:
            grid[x][y] = 2

        for i in range(m):
            for j in range(n):
                if grid[i][j] == -1:
                    # north
                    path = [[i, j]]
                    guarded = False
                    ti, tj = i - 1, j
                    while ti > -1:
                        cell = grid[ti][tj]
                        if cell == 2:
                            break
                        elif cell == 1:
                            guarded = True
                            break
                        path.append([ti, tj])
                        ti -= 1
                    if guarded:
                        for x, y in path:
                            grid[x][y] = 0

                    # east
                    path = [[i, j]]
                    guarded = False
                    ti, tj = i, j + 1
                    while tj < n:
                        cell = grid[ti][tj]
                        if cell == 2:
                            break
                        elif cell == 1:
                            guarded = True
                            break
                        path.append([ti, tj])
                        tj += 1
                    if guarded:
                        for x, y in path:
                            grid[x][y] = 0

                    # south
                    path = [[i, j]]
                    guarded = False
                    ti, tj = i + 1, j
                    while ti < m:
                        cell = grid[ti][tj]
                        if cell == 2:
                            break
                        elif cell == 1:
                            guarded = True
                            break
                        path.append([ti, tj])
                        ti += 1
                    if guarded:
                        for x, y in path:
                            grid[x][y] = 0

                    # west
                    path = [[i, j]]
                    guarded = False
                    ti, tj = i, j - 1
                    while tj > -1:
                        cell = grid[ti][tj]
                        if cell == 2:
                            break
                        elif cell == 1:
                            guarded = True
                            break
                        path.append([ti, tj])
                        tj -= 1
                    if guarded:
                        for x, y in path:
                            grid[x][y] = 0

        result = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == -1:
                    result += 1

        return result
```

Consulted for a hint: is it possible to scan each row and col only once.

```python
class Solution:
    def countUnguarded(
        self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]
    ) -> int:
        # intuition:
        # for each row/col, keep path
        # go until hits wall, if ever seen guard, mark all empty cells guarded
        # this trims the runtime to O(m*n)
        UNGUARDED = 0
        GUARDED = 1
        GUARD = 2
        WALL = 3

        grid = [[UNGUARDED for _ in range(n)] for _ in range(m)]
        for x, y in guards:
            grid[x][y] = GUARD
        for x, y in walls:
            grid[x][y] = WALL

        for i in range(m):
            j = 0
            path = []
            seen_guard = False
            while j < n:
                if grid[i][j] == UNGUARDED:
                    path.append([i, j])
                elif grid[i][j] == GUARD:
                    seen_guard = True
                elif grid[i][j] == WALL:
                    if seen_guard:
                        for x, y in path:
                            grid[x][y] = GUARDED
                        seen_guard = False
                    if path:
                        path = []
                j += 1
            # remainings till the end
            if seen_guard:
                for x, y in path:
                    grid[x][y] = GUARDED

        for j in range(n):
            i = 0
            path = []
            seen_guard = False
            while i < m:
                if grid[i][j] == UNGUARDED:
                    path.append([i, j])
                elif grid[i][j] == GUARD:
                    seen_guard = True
                elif grid[i][j] == WALL:
                    if seen_guard:
                        for x, y in path:
                            grid[x][y] = GUARDED
                        seen_guard = False
                    if path:
                        path = []
                i += 1
            # remainings till the end
            if seen_guard:
                for x, y in path:
                    grid[x][y] = GUARDED

        result = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == UNGUARDED:
                    result += 1

        return result
```

This is passing, but there is the "optimal" solution, which is to do a O(4mn) - like casting a flashlight from each direction, marking all cells after seeing a guard guarded and continue when hit a wall:

```python
class Solution:
    def countUnguarded(
        self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]
    ) -> int:
        # optimal: cast in 4 directions
        UNGUARDED = 0
        GUARDED = 1
        GUARD = 2
        WALL = 3

        grid = [[0 for _ in range(n)] for _ in range(m)]

        for i, j in guards:
            grid[i][j] = GUARD
        for i, j in walls:
            grid[i][j] = WALL

        # east
        for i in range(m):
            seen = False
            for j in range(n):
                if grid[i][j] == WALL:
                    seen = False
                elif grid[i][j] == GUARD:
                    seen = True
                elif grid[i][j] == UNGUARDED and seen:
                    grid[i][j] = GUARDED

        # south
        for j in range(n):
            seen = False
            for i in range(m):
                if grid[i][j] == WALL:
                    seen = False
                elif grid[i][j] == GUARD:
                    seen = True
                elif grid[i][j] == UNGUARDED and seen:
                    grid[i][j] = GUARDED

        # west
        for i in range(m):
            seen = False
            for j in range(n - 1, -1, -1):
                if grid[i][j] == WALL:
                    seen = False
                elif grid[i][j] == GUARD:
                    seen = True
                elif grid[i][j] == UNGUARDED and seen:
                    grid[i][j] = GUARDED

        # north
        for j in range(n):
            seen = False
            for i in range(m - 1, -1, -1):
                if grid[i][j] == WALL:
                    seen = False
                elif grid[i][j] == GUARD:
                    seen = True
                elif grid[i][j] == UNGUARDED and seen:
                    grid[i][j] = GUARDED

        result = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == UNGUARDED:
                    result += 1

        return result
```
