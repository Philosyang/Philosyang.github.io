---
title: "3219. Minimum Cost for Cutting Cake II | 1789"
date: 2025-11-09
tags: ["array", "greedy", "sorting", "heap", "python"]
---

I should be doing 3218 but accidently clicked on previous question so I clicked on next question twice and brought me to 3129 and I did not discover it because it's literally the same question - 3129 disallows O(n**2) but I am using nlogn anyways.

And for some reason that bumped the problem's rating from 1654 to 1789?

```python
class Solution:
    def minimumCost(
        self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]
    ) -> int:

        # wrong (almost correct) idea:
        # c = 0, h = [1,3,5], v = [6,1,1]
        # find max(max(h),max(v))
        # c = 6, h = [2,6,10], v = [1,1]
        # c = 16, h = [2,6], v = [2,2]
        # c = 22, h = [2], v = [3,3]
        # c = 25, h = [3], v = [3]
        # c = 28, h = [], v = [4]
        # c = 32

        # correct idea:
        # c = 0, h = [1,3,5] (1x), v = [6,1,1] (1x)
        # find max(max(h),max(v))
        # c = 6, h = [1,3,5] (2x), v = [1,1] (1x)
        # c = 16, h = [1,3] (2x), v = [1,1] (2x)
        # c = 22, h = [1] (2x), v = [1,1] (3x)
        # c = 24, h = [] (2x), v = [1,1] (4x)
        # c = 28, h = [] (3x), v = [1] (4x)
        # c = 32, h = [] (4x), v = [] (4x)

        # impl:
        # can use two maxheap with h_mult and v_mult, each += 1 when cutting the other dim
        # tbh we can also just sort - what's the fun tho; I love heapq
        c, h, v = 0, [], []
        heapq.heapify(h)
        heapq.heapify(v)
        h_mult, v_mult = 1, 1

        for cut in horizontalCut:
            heapq.heappush(h, -cut)
        for cut in verticalCut:
            heapq.heappush(v, -cut)

        while h or v:
            if h and v:
                hmax = -h[0]
                vmax = -v[0]
                if hmax > vmax:
                    heapq.heappop(h)
                    c += hmax * h_mult
                    v_mult += 1
                else:
                    heapq.heappop(v)
                    c += vmax * v_mult
                    h_mult += 1
            elif h:
                c += -heapq.heappop(h) * h_mult
            else:
                c += -heapq.heappop(v) * v_mult

        return c
```

takeaways:
1. heapq usage revision