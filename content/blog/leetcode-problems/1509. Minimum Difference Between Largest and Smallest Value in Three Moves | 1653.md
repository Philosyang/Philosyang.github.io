---
title: "1509. Minimum Difference Between Largest and Smallest Value in Three Moves | 1653"
date: 2025-11-06
tags: ["array", "greedy", "sorting", "heap", "python"]
---

Easy! /ignorant

```python
class Solution:
    def minDifference(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 4:
            return 0

        nums.sort()
        # print(nums)

        diff = [-1] * (n - 1)
        diff_sum = 0

        for i in range(n - 1):
            diff_cur = nums[i + 1] - nums[i]
            diff[i] = diff_cur
            diff_sum += diff_cur

        # print(diff)
        # print(diff_sum)

        # only 4 possible situations.
        # [-,-,-,...]
        # [-,-,...,-]
        # [-,...,-,-]
        # [...,-,-,-]

        return diff_sum - max(
            sum(diff[:3]),
            sum(diff[-3:]),
            diff[0] + diff[1] + diff[-1],
            diff[0] + diff[-1] + diff[-2],
        )
```

I made my answer a bit more complex than needed, I actually don't need the diff array at all:

```python
class Solution:
    def minDifference(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 4:
            return 0
        nums.sort()
        return min(
            nums[-1] - nums[3],
            nums[-2] - nums[2],
            nums[-3] - nums[1],
            nums[-4] - nums[0],
        )
```

... and we can actually do this without the need of an nlogn sort:

```python
class Solution:
    def minDifference(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 4:
            return 0
        mins = heapq.nsmallest(4, nums)   # ascending
        maxs = heapq.nlargest(4, nums)    # descending
        return min(
            maxs[0] - mins[3],
            maxs[1] - mins[2],
            maxs[2] - mins[1],
            maxs[3] - mins[0],
        )
```

This is nlogk where k == 4, thus effectively linear.

takeaways:
1. heapq (nsmallest and nlargest) revision