---
title: "1947. Maximum Compatibility Score Sum | 1704"
date: 2025-12-05
tags: ["array", "backtracking", "python", "revisit"]
---

This is a really helpful question! I need more backtracking.

Wrong but close implementation:

```python
class Solution:
    def maxCompatibilitySum(
        self, students: List[List[int]], mentors: List[List[int]]
    ) -> int:
        # brute force i.e., backtracking
        # current_score = 0, remaining_students = [0, 1, 2], remaining_mentors = [0, 1, 2]
        # current_score += student0 x mentor0, rs = [1, 2], rm = [1, 2]

        def calculateScore(a: List[int], b: List[int]) -> int:
            # assert len(a) == len(b)
            result = 0
            for i in range(len(a)):
                if a[i] == b[i]:
                    result += 1
            return result

        def bt(score: int, rs: List[int], rm: List[int]) -> int:
            # print("bt:", rs, rm)
            if not rs or not rm:
                return score

            best_score = score
            for i in range(len(rs)):
                nrs = rs.copy()
                del nrs[i]
                for j in range(len(rm)):
                    nrm = rm.copy()
                    del nrm[j]
                    # print("nrs/rm:", nrs, nrm)
                    best_score = max(
                        best_score,
                        bt(score + calculateScore(students[i], mentors[j]), nrs, nrm),
                    )

            return best_score

        return bt(0, list(range(len(students))), list(range(len(mentors))))
```

The problem with the above code is that:

```python
for i in range(len(rs)):
...
    for j in range(len(rm)):
...
        calculateScore(students[i], mentors[j])
```

After the first deletion, rs might be [1, 2], but i = 0 would still access students[0] instead of students[1].

v2, TLE:

```python
class Solution:
    def maxCompatibilitySum(
        self, students: List[List[int]], mentors: List[List[int]]
    ) -> int:
        # brute force i.e., backtracking
        # current_score = 0, remaining_students = [0, 1, 2], remaining_mentors = [0, 1, 2]
        # current_score += student0 x mentor0, rs = [1, 2], rm = [1, 2]

        def calculateScore(a: List[int], b: List[int]) -> int:
            # assert len(a) == len(b)
            result = 0
            for i in range(len(a)):
                if a[i] == b[i]:
                    result += 1
            return result

        def bt(score: int, rs: List[int], rm: List[int]) -> int:
            if not rs or not rm:
                return score

            best_score = score
            for i in range(len(rs)):
                s_idx = rs[i]
                nrs = rs[:i] + rs[i + 1 :]
                for j in range(len(rm)):
                    m_idx = rm[j]
                    nrm = rm[:j] + rm[j + 1 :]
                    best_score = max(
                        best_score,
                        bt(
                            score + calculateScore(students[s_idx], mentors[m_idx]),
                            nrs,
                            nrm,
                        ),
                    )

            return best_score

        return bt(0, list(range(len(students))), list(range(len(mentors))))
```

This TLEs because it's actually O((n!)^2).  
8 students * 8 mentors * 7 students * 7 mentors * ...  
We are actually overcounting.

My current implementation:  
s0m0, s1m1, s2m2  
s0m0, s1m2, s2m1  
s0m0, s2m1, s1m2 (!)  
s0m0, s2m2, s1m1 (!)  
...

If we lock the sequence of students, we can still consider all the possibilities:  
s0m0, s1m1, s2m2  
s0m0, s1m2, s2m1  
s0m1, s1m0, s2m2 (good)  
...

This also brings the complexity down to O(n * n!) which becomes O(n!).

```python
class Solution:
    def maxCompatibilitySum(
        self, students: List[List[int]], mentors: List[List[int]]
    ) -> int:
        # precomputing scores can cut some complexity (tho not decisive):
        # s0m0, s1m1, s2m2
        # s0m0, s1m2, s2m1
        # s0m0 can be computed once and fetched later
        n = len(students)

        def calculateScore(a: List[int], b: List[int]) -> int:
            result = 0
            for i in range(len(a)):
                if a[i] == b[i]:
                    result += 1
            return result

        score_table = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(n):
                score_table[i][j] = calculateScore(students[i], mentors[j])

        # lock student sequence to cut big O from `n! * n!` to `n! * n`
        def bt(
            current_score: int, current_student: int, remaining_mentors: List[int]
        ) -> int:
            if current_student >= n:  # out of bounds == combo explored
                return current_score

            best_score = 0
            for i in range(len(remaining_mentors)):
                m_idx = remaining_mentors[i]
                best_score = max(
                    best_score,
                    bt(
                        current_score + score_table[current_student][m_idx],
                        current_student + 1,
                        remaining_mentors[:i] + remaining_mentors[i + 1 :],
                    ),
                )

            return best_score

        return bt(0, 0, list(range(len(mentors))))
```

Very useful question.