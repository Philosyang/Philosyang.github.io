---
title: "3532. Path Existence Queries in a Graph I | 1659"
date: 2025-11-17
tags: ["graph", "union-find", "python"]
---

initial union find version:

```python
class DSU:
    def __init__(self, n):
        self.rank = [0] * n
        self.parent = [i for i in range(n)]

    def find(self, i):
        if self.parent[i] != i:
            self.parent[i] = self.find(self.parent[i])

        return self.parent[i]

    def union(self, i, j):
        i_parent = self.find(i)
        j_parent = self.find(j)

        if i_parent == j_parent:
            return

        i_parent_rank = self.rank[i_parent]
        j_parent_rank = self.rank[j_parent]

        if i_parent_rank < j_parent_rank:
            self.parent[i_parent] = j_parent
        elif i_parent_rank > j_parent_rank:
            self.parent[j_parent] = i_parent
        else:
            self.parent[j_parent] = i_parent
            self.rank[i_parent] += 1


class Solution:
    def pathExistenceQueries(
        self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]
    ) -> List[bool]:
        # feels like a perfect problem for union find

        uf = DSU(n)

        l, r = 0, 0
        while r < n:
            while r < n and abs(nums[l] - nums[r]) <= maxDiff:
                uf.union(l, r)
                r += 1
            while r < n and abs(nums[l] - nums[r]) > maxDiff:
                l += 1

        return [uf.find(a) == uf.find(b) for a, b in queries]
```

same asymptotic but better code:

```python
class DSU:
    def __init__(self, n):
        self.rank = [0] * n
        self.parent = [i for i in range(n)]

    def find(self, i):
        if self.parent[i] != i:
            self.parent[i] = self.find(self.parent[i])

        return self.parent[i]

    def union(self, i, j):
        i_parent = self.find(i)
        j_parent = self.find(j)

        if i_parent == j_parent:
            return

        i_parent_rank = self.rank[i_parent]
        j_parent_rank = self.rank[j_parent]

        if i_parent_rank < j_parent_rank:
            self.parent[i_parent] = j_parent
        elif i_parent_rank > j_parent_rank:
            self.parent[j_parent] = i_parent
        else:
            self.parent[j_parent] = i_parent
            self.rank[i_parent] += 1


class Solution:
    def pathExistenceQueries(
        self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]
    ) -> List[bool]:
        uf = DSU(n)

        # Only need to connect adjacent indices when their values are close enough.
        for i in range(n - 1):
            if nums[i + 1] - nums[i] <= maxDiff:
                uf.union(i, i + 1)

        return [uf.find(u) == uf.find(v) for u, v in queries]
```

---

DSU is actually not required for this problem:

```python
class Solution:
    def pathExistenceQueries(
        self, n: int, nums: List[int], maxDiff: int, queries: List[List[int]]
    ) -> List[bool]:
        comp = [0] * n  # component id
        comp[0] = 0
        for i in range(1, n):
            if nums[i] - nums[i-1] <= maxDiff:
                comp[i] = comp[i-1]
            else:
                comp[i] = i  # new component

        return [comp[u] == comp[v] for u, v in queries]
```