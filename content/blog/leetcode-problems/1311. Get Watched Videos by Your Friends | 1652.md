---
title: "1311. Get Watched Videos by Your Friends | 1652"
date: 2025-11-06
tags: ["array", "hashing", "breadth-first-search", "graph", "sorting", "python"]
---

You know it's a graph question when you see the title. It's a good BFS refresher, but I stumbled on sorting and it helped.

```python
class Solution:
    def watchedVideosByFriends(
        self,
        watchedVideos: List[List[str]],
        friends: List[List[int]],
        id: int,
        level: int,
    ) -> List[str]:
        # use bfs to find friends list given level
        dq = deque()
        dq.append((id, 0))
        seen = set([id])

        while dq and dq[0][1] < level:
            cur_id, cur_level = dq.popleft()
            for friend in friends[cur_id]:
                if friend not in seen:
                    seen.add(friend)
                    dq.append((friend, cur_level + 1))
        # print(dq)

        video_stats = []
        while dq:
            cur_id, cur_level = dq.popleft()
            video_stats.extend(watchedVideos[cur_id])
        video_cnt = Counter(video_stats)
        # print(video_cnt)

        sorted_result = sorted(video_cnt.items(), key=lambda x: (x[1], x[0]))
        return [video for video, _ in sorted_result]
```

things to improve on:

1. Level-order BFS: iterate by layers instead of storing (id, level) tuples. This avoids tracking levels per node and makes intent clear.
2. Avoid the intermediate list: update the Counter directly from each friend’s videos.
3. Drop unused vars: you don’t use cur_level when collecting videos.
4. Tiny style nits: initialize deque with a list; use descriptive names.

```python
class Solution:
    def watchedVideosByFriends(
        self,
        watchedVideos: List[List[str]],
        friends: List[List[int]],
        id: int,
        level: int,
    ) -> List[str]:
        # BFS to get exactly the friends at the given level
        seen = {id}
        q = deque([id])

        for _ in range(level):
            for _ in range(len(q)):          # iterate one "layer"
                u = q.popleft()
                for v in friends[u]:
                    if v not in seen:
                        seen.add(v)
                        q.append(v)

        # q now contains all friends at exactly 'level' distance
        cnt = Counter()
        for u in q:
            cnt.update(watchedVideos[u])

        # sort by (frequency asc, title asc) and return titles
        return [title for title, _ in sorted(cnt.items(), key=lambda kv: (kv[1], kv[0]))]
```

takeaways:

1. for loops for a specific level with bfs
2. Counter.update()
3. sorted(, key=lambda x)

This is a nice question!