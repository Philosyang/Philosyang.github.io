---
title: "1514. Path with Maximum Probability | 1846"
date: 2025-11-28
tags: ["graph", "python"]
---

Picked this one to sharpen on Dijkstra.

```python
class Solution:
    def maxProbability(
        self,
        n: int,
        edges: List[List[int]],
        succProb: List[float],
        start_node: int,
        end_node: int,
    ) -> float:
        # variation of dijkstras
        # probability ranges from 1 to 0
        # to still use min heap, we can use "fail rate"
        # fail_rate[start_node] = 0
        # shortest path -~> lowest fail rate

        # dijkstra is okay with undirected and/or cycles

        # build adj dict
        adj = defaultdict(list)
        for i in range(len(edges)):  # not necessarily n
            adj[edges[i][0]].append([1 - succProb[i], edges[i][1]])
            adj[edges[i][1]].append([1 - succProb[i], edges[i][0]])

        # build dist i.e. fail rate
        dist = [1] * n
        dist[start_node] = 0

        # build min heap pq
        pq = [(0, start_node)]  # fail_rate, node

        while pq:
            fail_rate, node = heapq.heappop(pq)

            if fail_rate > dist[node]:
                continue

            if node == end_node:  # early exit, guaranteed best result with pq
                return 1 - fail_rate

            for node_to_neighbor_fail_rate, neighbor in adj[node]:
                # new fail rate = 1 - new pass rate = 1 - ((1-old_fail_rate)*(1-new_fail_rate))
                new_fail_rate = 1 - ((1 - fail_rate) * (1 - node_to_neighbor_fail_rate))
                if new_fail_rate < dist[neighbor]:
                    dist[neighbor] = new_fail_rate
                    heapq.heappush(pq, (new_fail_rate, neighbor))

        return 0
```