---
title: "3350. Adjacent Increasing Subarrays Detection II | 1600"
date: 2025-10-31
tags: ["neetcode150", "array", "python"]
---

Happy halloween?

```python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        # strictly increasing combo array
        # [2,5,7,8,9,2,3,4,3,1]
        # [5 4 3 2 1 3 2 1 1 1] expand from back to front when back > front
        # [5 x x x x y x x x x] we need to check (if y==5) n times, each costing O(1) idx value lookup
        # early skip includes if lower than current best result

        # also possible:
        # [5 4 3 2 1 3 2 1 1 1] expand from back to front when back > front
        # [x x y x x 3 x x y x] we need to check (if y>=3) n times, each costing O(2) idx value lookup

        # also possible:
        # [1,2,3,4,5,6,7,8,0,0]
        # [8 7 6 5 4 3 2 1 1 1] expand from back to front when back > front
        # [x x a x x b x x c x]
        # when at b, we check whether a >= b or c >= b

        n = len(nums)
        combo = [1] * n
        k = 1

        for i in range(n - 2, -1, -1):
            combo[i] = combo[i + 1] + 1 if nums[i + 1] > nums[i] else 1

        # print(combo)

        for i in range(n):
            current_combo = combo[i]
            if current_combo > k:
                prior_idx = i - combo[i]
                post_idx = i + combo[i]
                if prior_idx >= 0 and current_combo <= combo[prior_idx]:
                    k = max(k, current_combo)
                elif post_idx < n and current_combo <= combo[post_idx]:
                    k = max(k, current_combo)

        return k
```