---
title: "1091. Shortest Path in Binary Matrix | 1658"
date: 2025-11-18
tags: ["graph", "python"]
---

I will use the sledgehammer (Dijkstra's) to crack the nut (BFS-able question) because I am unfortunately trying to level up my sledgehammer.

```python
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        if grid[0][0] != 0:
            return -1

        n = len(grid)
        graph = {}  # (1, x, y) means distance == 1 at row x, col y

        def possiblePaths(coord):
            x, y = coord
            result = []
            # right
            if y + 1 < n and grid[x][y + 1] == 0:
                result.append((1, x, y + 1))
            # bottom-right
            if x + 1 < n and y + 1 < n and grid[x + 1][y + 1] == 0:
                result.append((1, x + 1, y + 1))
            # bottom
            if x + 1 < n and grid[x + 1][y] == 0:
                result.append((1, x + 1, y))
            # bottom-left
            if x + 1 < n and y - 1 > -1 and grid[x + 1][y - 1] == 0:
                result.append((1, x + 1, y - 1))
            # left
            if y - 1 > -1 and grid[x][y - 1] == 0:
                result.append((1, x, y - 1))
            # top-left
            if x - 1 > -1 and y - 1 > -1 and grid[x - 1][y - 1] == 0:
                result.append((1, x - 1, y - 1))
            # top
            if x - 1 > -1 and grid[x - 1][y] == 0:
                result.append((1, x - 1, y))
            # top-right
            if x - 1 > -1 and y + 1 < n and grid[x - 1][y + 1] == 0:
                result.append((1, x - 1, y + 1))

            return result

        for x in range(n):
            for y in range(n):
                if grid[x][y] == 0:
                    graph[(x, y)] = possiblePaths((x, y))

        dist = {coord: float("inf") for coord in graph.keys()}
        dist[(0, 0)] = 1

        # prev = {coord: None for coord in graph.keys()}

        pq = [(1, (0, 0))]
        heapq.heapify(pq)

        visited = set()

        while pq:
            current_dist, current_node = heapq.heappop(pq)

            if current_node in visited:
                continue

            visited.add(current_node)

            if current_node == (n - 1, n - 1):
                return current_dist

            for weight, x, y in graph[current_node]:
                neighbor = (x, y)
                new_dist = current_dist + weight

                if new_dist < dist[neighbor]:
                    dist[neighbor] = new_dist
                    # prev[neighbor] = current_node
                    heapq.heappush(pq, (new_dist, neighbor))

        return -1
```

it's O(n^2 logn) because Dijkstra's is O((V+E)logV) = O(n^2 log(n^2)) = O(n^2 logn)