---
title: "155. Min Stack: with deque"
date: 2025-07-15
tags: ["neetcode150", "stack", "deque", "python"]
---

The _canonical_ way to solve this is by using two stacks. However, I have been using deque for so many times that I could not help but to think about solving it with a deque.

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.track = deque()

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.track or val <= self.track[-1]:
            self.track.append(val)
        else:
            self.track.appendleft(val)

    def pop(self) -> None:
        if self.stack:
            temp = self.stack.pop()
            if self.track[-1] == temp:
                self.track.pop()
            else:
                self.track.popleft()

    def top(self) -> int:
        return self.stack[-1] if self.stack else None

    def getMin(self) -> int:
        return self.track[-1] if self.track else None
```

The gist of this deque is to fully utilize its O(1) trait for push and pop(peek) from either end.

We push and pop this deque together with stack, but we choose which end to push to. The deque is always intact in a way that the top of the stack must be either `deque[0]` or `deque[-1]` no matter when.

We only push to the right if `val <= deque[-1]`, otherwise we push to the left. This promises us the current minimum element will always be `deque[-1]`.