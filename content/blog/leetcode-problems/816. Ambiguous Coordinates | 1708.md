---
title: "816. Ambiguous Coordinates | 1708"
date: 2025-12-10
tags: ["string", "enumeration", "python"]
---


What another weird question...

My initial thoughts:

```python
class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        # intuition:
        # enum problem...
        # there must be one and only one comma, decimal 0/1/2
        # common example: 123
        # comma asap, decimal asap: (1, 2.3) (1, 23) (1.2, 3) (12, 3)
        # decimal can't have ending zeros
        # number can't start with zero unless immediately a decimal

        def normalize(s: str) -> str:
            # return "" if illegal combination
            if (
                s.startswith(",")
                or s.endswith(",")
                or s.count(",") != 1
                or s.count(".") > 2
            ):
                return ""
            comma_location = s.find(",")
            s0, s1 = s[:comma_location], s[comma_location + 1 :]
            print(s0, s1)

            split_list = [s0, s1]
            combined = []
            for split in split_list:
                if "." in split:
                    if split.endswith("0"):
                        return ""
                if split.startswith("0"):
                    if not split.startswith("0."):
                        if split != "0":
                            return ""

                combined.append(split)

            return "(" + combined[0].strip() + ", " + combined[1].strip() + ")"

        print(normalize("1,23"))
```

I should have planned this sooner but, it is not very easy to code an enum that goes through all possible ',' and '.' combinations.
Therefore I took a hint: Separate the problems: comma vs decimals - First, fix the comma position, then handle decimals independently on each side.

```python
class Solution:
    def ambiguousCoordinates(self, s: str) -> List[str]:
        # intuition after hint:
        # comma vs decimals - First, fix the comma position, then handle decimals independently on each side.
        digits = s[1:-1]
        result = []

        # given s: str, generate all valid numeric strings
        def generateValidCombo(s: str) -> List[str]:
            result = []
            n = len(s)

            if n == 1:
                return [s]
            if s.startswith("0") and s.endswith("0"):
                return []
            if s.startswith("0"):
                return ["0." + s[1:]]
            if s.endswith("0"):
                return [s]

            result.append(s)
            for i in range(1, n):
                result.append(s[:i] + "." + s[i:])

            return result

        for i in range(1, len(digits)):
            l = digits[:i]
            r = digits[i:]

            # now the problem becomes: generate all valid numeric strings
            lc = generateValidCombo(l)
            rc = generateValidCombo(r)

            for a in lc:
                for b in rc:
                    result.append("(" + a + ", " + b + ")")

        return result
```