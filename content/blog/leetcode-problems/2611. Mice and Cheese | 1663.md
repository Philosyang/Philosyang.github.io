---
title: "2611. Mice and Cheese | 1663"
date: 2025-11-25
tags: ["array", "greedy", "sorting", "heap", "python"]
---

Am I greedy if I am good at greedy problems?

```python
class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        # reward1 = [1, 1, 3, 4]
        # reward2 = [4, 4, 1, 1]
        # delta   = [-3,-3,2, 3]    # if eating reward1, how many points to get compared to eating reward2

        n = len(reward1)
        delta = []
        heapq.heapify(delta)

        for i in range(n):
            # min heap so push inverted
            heapq.heappush(delta, (reward2[i] - reward1[i], i))

        reward1_index = set()

        for j in range(k):
            reward1_index.add(heapq.heappop(delta)[1])

        result = 0
        for x in range(n):
            if x in reward1_index:
                result += reward1[x]
            else:
                result += reward2[x]

        return result
```

asymtotically optimal but there are improvables (thanks LLM):
- heapq.heapify(delta) on an empty list is unnecessary (no harm though).
- You don’t need to store indices or a set if you switch to the “base sum + diffs” pattern.
- Using heapq.nsmallest(k, delta) could also simplify the popping loop, but sorting is usually clearer.