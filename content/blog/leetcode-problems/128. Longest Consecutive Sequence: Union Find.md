---
title: "128. Longest Consecutive Sequence: Union Find"
date: 2025-07-21
tags: ["neetcode150", "arrays", "union-find", "python"]
---

We first scaffold our union find:
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        
        class DSU:
            def __init__(self, n):
                self.rank = [0] * n
                self.parent = list(range(n))
            
            def find(self, i):
                if self.parent[i] != i:
                    self.parent[i] = self.find(self.parent[i])
                return self.parent[i]
            
            def union(self, i, j):
                ip = self.find(i)
                jp = self.find(j)

                if ip == jp:
                    return
                
                if self.rank[ip] < self.rank[jp]:
                    self.parent[ip] = jp
                elif self.rank[ip] > self.rank[jp]:
                    self.parent[jp] = ip
                else:
                    self.parent[jp] = ip
                    self.rank[ip] += 1

        return -1
```

we need a way to actually use our DSU in this problem.

In this problem, we want to union all consecutive numbers. Furthermore, we also need to keep track of the sizes.

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        
        class DSU:
            def __init__(self, n):
                self.rank = [0] * n
                self.parent = list(range(n))
                self.size = [1] * n # size connected; singleton for all num at first
            
            def find(self, i):
                if self.parent[i] != i:
                    self.parent[i] = self.find(self.parent[i])
                return self.parent[i]
            
            def union(self, i, j):
                ip = self.find(i)
                jp = self.find(j)

                if ip == jp:
                    return
                
                if self.rank[ip] < self.rank[jp]:
                    self.parent[ip] = jp
                    self.size[jp] += self.size[ip]  # update sizes upon union
                elif self.rank[ip] > self.rank[jp]:
                    self.parent[jp] = ip
                    self.size[ip] += self.size[jp]
                else:
                    self.parent[jp] = ip
                    self.rank[ip] += 1
                    self.size[ip] += self.size[jp]
```

We need a way to put the nums into our DSU.

```python
        n = len(nums)
        uf = DSU(n)

        for i,num in enumerate(nums):
            if num + 1 in ...
```

We need a hash-typed structure to reduce our check down to O(1).

```python
        n = len(nums)
        lookup = set(nums)  # hashset
        uf = DSU(n)

        for i,num in enumerate(nums):
            if num + 1 in lookup:
                uf.union(i, i+1)
        
        return max(uf.size)
```

The above code is incorrect: we actually want the index of `num+1` (not `i+1`) - we want to union the _indices_ of these two nums.

We thus think about _upgrading_ our hashset to a hashmap.

```python
        n = len(nums)
        lookup = {num: idx for idx, num in enumerate(nums)} # free real estate
        uf = DSU(n)

        for i, num in enumerate(nums):
            if num + 1 in lookup.keys():
                uf.union(i, lookup[num + 1])

        return max(uf.size)
```

We are close, yet this code is still incorrect.

When the same number shows up twice, we ended up counting it twice in the component’s size (which is wrong since we want the size of longest consecutive - [1,2,2,3] should return 3).

Therefore we think about a way to dedupe `nums`, deduping won't hurt because it doesn't change the longest consecutive sequence.

```python
        uniq = set(nums)    # dedupe
        n = len(uniq)
        lookup = {num: idx for idx, num in enumerate(uniq)}
        uf = DSU(n)

        for i, num in enumerate(uniq):
            if num + 1 in uniq:
                uf.union(i, lookup[num + 1])

        return max(uf.size)
```

besides from the above method, we can also choose to skip duplicates while building lookup if we don't want to dedupe. (Personally I prefer the dedupe.)

```python3
        lookup = {}
        for i, num in enumerate(nums):
            if num not in lookup: # ignore duplicates
                lookup[num] = i
```

---

Now we have a _correct_ code with O(n × α(n)) time.

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0

        class DSU:
            def __init__(self, n):
                self.rank = [0] * n
                self.parent = list(range(n))
                self.size = [1] * n  # size connected for this num

            def find(self, i):
                if self.parent[i] != i:
                    self.parent[i] = self.find(self.parent[i])
                return self.parent[i]

            def union(self, i, j):
                ip = self.find(i)
                jp = self.find(j)

                if ip == jp:
                    return

                if self.rank[ip] < self.rank[jp]:
                    self.parent[ip] = jp
                    self.size[jp] += self.size[ip]
                elif self.rank[ip] > self.rank[jp]:
                    self.parent[jp] = ip
                    self.size[ip] += self.size[jp]
                else:
                    self.parent[jp] = ip
                    self.rank[ip] += 1
                    self.size[ip] += self.size[jp]

        uniq = set(nums)
        n = len(uniq)
        lookup = {num: idx for idx, num in enumerate(uniq)}
        uf = DSU(n)

        for i, num in enumerate(uniq):
            if num + 1 in uniq:
                uf.union(i, lookup[num + 1])

        return max(uf.size)
```

We can think about improving this code. The lowest hanging fruit is that we can ditch rank and rely solely on size to union.

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0

        class DSU:
            def __init__(self, n):
                self.parent = list(range(n))
                self.size = [1] * n  # size connected for this num

            def find(self, i):
                if self.parent[i] != i:
                    self.parent[i] = self.find(self.parent[i])
                return self.parent[i]

            def union(self, i, j):
                ip = self.find(i)
                jp = self.find(j)

                if ip == jp:
                    return

                if self.size[ip] < self.size[jp]:
                    self.parent[ip] = jp
                    self.size[jp] += self.size[ip]
                else:   # > and = have exactly the same operations w/o rank
                    self.parent[jp] = ip
                    self.size[ip] += self.size[jp]

        uniq = set(nums)
        n = len(uniq)
        lookup = {num: idx for idx, num in enumerate(uniq)}
        uf = DSU(n)

        for i, num in enumerate(uniq):
            if num + 1 in uniq:
                uf.union(i, lookup[num + 1])

        return max(uf.size)
```

We can also build `lookup` and union in the same loop, but our union find is correct and concise enough for this practice.

Union find is cool!