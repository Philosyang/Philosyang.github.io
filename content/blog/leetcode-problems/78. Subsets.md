---
title: "78. Subsets"
date: 2026-02-18
tags: ["neetcode150", "backtracking", "python"]
---

I overcomplicated things and failed on backtracking. More practice!

wrong impl:

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []

        def bt(subset: List[int], rem_pick_count: int, rem_nums_index: List[int]) -> None:
            if rem_pick_count == 0:
                result.append(subset[:])
                return
            
            n = len(rem_nums_index)
            
            # debug: pick_count should be at least 1
            for pick_count in range(rem_pick_count):
                for i in range(n):
                    if i < n:   # early prune
                        subset.append(nums[rem_nums_index[i]])
                        bt(subset, pick_count-1, rem_nums_index[i+1:])
                        subset.pop()
            
            return
        
        bt([], len(nums), range(len(nums)))

        return result
```

take-aways from wrong impl:

1. **Overcomplicated state**: Tracking `rem_pick_count` and `rem_nums_index` adds unnecessary dimensions. The correct approach only needs a `start` index - simpler state means fewer places to go wrong.
2. **Wrong base case**: Only collecting subsets when `rem_pick_count == 0` misses the key insight: every node in the recursion tree is a valid subset. The correct version appends `subset[:]` at every recursive call, not just at a terminal condition.
3. **Nested loop is the root bug**: The `for pick_count in range(rem_pick_count)` loop tries to pre-decide how many more elements to pick, then recurses with `pick_count - 1`. When `pick_count` is 0 this passes -1, which never hits the base case correctly. This produces duplicates and misses subsets.
4. **Dead pruning**: `if i < n` is always true since `i` comes from `range(n)` - a sign the logic was patched rather than rethought.
5. **Unnecessary copying**: Slicing `rem_nums_index[i+1:]` allocates a new list at every call. Passing a single `start` int is O(1) and cleaner.
6. **Lesson**: For subset generation, the standard pattern is "at each index, include or skip, then advance." Don't try to layer a pick-count on top - it turns a clean one-loop recursion into a confusing two-loop mess.

correct:

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        n = len(nums)

        def bt(subset: List[int], start: int) -> None:
            result.append(subset[:])

            for i in range(start, n):
                subset.append(nums[i])
                bt(subset, i + 1)
                subset.pop()

            return

        bt([], 0)

        return result
```