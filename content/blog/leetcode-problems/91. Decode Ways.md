---
title: "91. Decode Ways"
date: 2026-02-08
tags: ["neetcode150", "string", "dynamic-programming", "python", "revisit"]
---

Partially correct idea but incorrect base case:

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        # idea:
        # dfs
        # look ahead 2 digits:
        # if starts with 0, return 0
        # if starts with 1 and second digit 0, return 1 + ways(index+2)
        # if starts with 1, return ways(index+1) + ways(index+2)
        # if starts with 2 and second digit 0, return 1 + ways(index+2)
        # if starts with 2 and second digit 1-6, return ways(index+1) + ways(index+2)
        # else (if starts with 2 and second digit >6), return ways(index+1)

        # '123'
        # 1, 2, 3
        # 1, 23
        # 12, 3

        n = len(s)


        def decodeWay(index: int) -> int:
            if index >= n:
                return 0
            d0 = int(s[index])
            if index == n-1:
                return 1 if d0 != 0 else 0
            d1 = int(s[index+1])

            if d0 == 0:
                return 0
            if d0 == 1 and d1 == 0:
                return 1 + decodeWay(index+2)
            if d0 == 1:
                return 1 + decodeWay(index+1) + decodeWay(index+2)
            pass
```

Needed a hint: reaching the end means return 1, else return 0.

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)

        @lru_cache(None)
        def decodeWay(i: int) -> int:
            if i == n:
                return 1
            if s[i] == '0':
                return 0
            
            # one digit
            ways = decodeWay(i+1)
            # two digits if valid
            if i+1<n and (s[i] == '1' or (s[i] == '2' and s[i+1] <= '6')):
                ways += decodeWay(i+2)
        
            return ways
```
