---
title: "1155. Number of Dice Rolls With Target Sum | 1654"
date: 2025-11-08
tags: ["dynamic-programming", "python", "revisit"]
---

Finally some DP!!!

Wrong answer but correct intuition:

```python
class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        # n = 3, k = 6, target = 5
        # 1+1+3
        # 1+2+2
        # 1+3+1
        # 2+1+2
        # 2+2+1
        # 3+1+1

        # n = 3, k = 6, target = 17
        # 5+6+6
        # 6+5+6
        # 6+6+5

        # the first die can range from
        # max(target - k*(n-1), 1)
        # min(target - 1*(n-1), k), both inclusive

        # the second die
        # max(target - k*(n-2) - sum(prev_dice), 1)
        # min(target - 1*(n-2) - sum(prev_dice), k)

        # the i-th die
        # max(target - k*(n-i) - sum(prev_dice), 1)
        # min(target - 1*(n-i) - sum(prev_dice), k)

        # recursive? dp?
        modulo = 10**9 + 7

        def recursiveDice(i: int, sum_prev_dice: int, mod_ways: int) -> int:  # n dice, k sides, target is global
            # base: last die to throw
            if i == n:
                assert sum_prev_dice + k >= target and sum_prev_dice < target
                return 1  # there's only one way to bridge sum_prev_dice to target

            lo = max(target - k * (n - i) - sum_prev_dice, 1)
            hi = min(target - 1 * (n - i) - sum_prev_dice, k)

            for j in range(lo, hi + 1):
                mod_ways += recursiveDice(i + 1, sum_prev_dice + j, mod_ways)
                mod_ways %= modulo

            return mod_ways

        result = recursiveDice(1, 0, 0)

        return result
```

I was really close, but `mod_ways` is erroneous here since it can bleed into dfs. I also need to use memoization.  
A minimal tweak solution:

```python
class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        modulo = 10**9 + 7

        @lru_cache(None)
        def recursiveDice(i: int, sum_prev_dice: int) -> int:  # n dice, k sides, target is global
            # base: last die to throw
            if i == n:
                # assert sum_prev_dice + k >= target and sum_prev_dice < target
                if sum_prev_dice + k < target or sum_prev_dice >= target:
                    return 0
                return 1  # there's only one way to bridge sum_prev_dice to target

            lo = max(target - k * (n - i) - sum_prev_dice, 1)
            hi = min(target - 1 * (n - i) - sum_prev_dice, k)

            mod_ways = 0
            for j in range(lo, hi + 1):
                mod_ways += recursiveDice(i + 1, sum_prev_dice + j)
                mod_ways %= modulo

            return mod_ways

        result = recursiveDice(1, 0)

        return result
```

great takeaways:
1. global variables should not be fed into recursion, find a way to extract it and keep track outside.
2. `@lru_cache(None)` memoization.
