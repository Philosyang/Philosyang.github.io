---
title: "863. All Nodes Distance K in Binary Tree | 1663"
date: 2025-11-22
tags: ["tree", "breadth-first-search", "python"]
---

Straightforward.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        # intuit: find a way to store self.parent
        # since Node.val are unique, a simple dict should work
        # we also can't look back: e.g., 5 -> 2 -> 5
        # therefore we can also use a visited set() to prevent looping
        # bfs is easier for distance problems

        parent = {}
        visited = set()

        # first traversal map parent{}
        q = deque([(root, None)])  # node, node.parent

        while q:
            node, node_parent = q.popleft()
            parent[node.val] = node_parent
            if node.left:
                q.append((node.left, node))
            if node.right:
                q.append((node.right, node))

        q = deque([(target, 0)])  # node, distance
        result = []

        while q:
            node, dist = q.popleft()
            if dist == k:
                result.append(node.val)
                continue
            visited.add(node.val)

            if node.left and node.left.val not in visited:
                q.append((node.left, dist + 1))
            if node.right and node.right.val not in visited:
                q.append((node.right, dist + 1))
            parent_node = parent[node.val]
            if parent_node and parent_node.val not in visited:
                q.append((parent_node, dist + 1))

        return result
```