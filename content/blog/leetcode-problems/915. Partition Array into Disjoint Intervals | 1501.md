---
title: "915. Partition Array into Disjoint Intervals | 1501"
date: 2025-10-30
tags: ["neetcode150", "array", "python"]
---

When you play maimai at Round1 at 11:00pm and the other one playing with you is a youtube employee that tells you better ways to conquer leetcode.

> https://zerotrac.github.io/leetcode_problem_rating/#/

Will start with rating 1500+ and see if it's an appropriate level for me.

---

My initial solution is passing, but it's using O(nlogn) (i sorted the right part) instead of an optimal O(n).

```python
class Solution:
    def partitionDisjoint(self, nums: List[int]) -> int:
        # we can start with the first min(nums) if we want
        pivot = 1
        l_max = nums[0]

        # for right, we keep track of how many times each value occurs, so that we know "this is the last `3` in the right"
        r_dict = Counter(nums[1:])
        # need a sorted list to quickly find the next smallest value in right
        r_sorted = sorted(list(r_dict.keys()))  # O(nlogn)
        # need a pointer to skip further when next in list is already zero
        r_sorted_ptr = 0
        r_min = r_sorted[r_sorted_ptr]

        while l_max > r_min:
            # idea:
            # put right[0] to left (we don't fully track left)
            # 1. update l_max if it's the new largest in left
            # 2. count -= 1 in right
            # 3. check whether this is the current r_min
            # 3.1 if so, check whether this is the last r_min in right
            # 3.1.1 if so, iterate r_sorted_ptr until r_dict[r_sorted[r_sorted_ptr]] > 0
            # that would be our new r_min
            spotlight = nums[pivot]
            if spotlight > l_max:
                l_max = spotlight

            r_dict[spotlight] -= 1
            if spotlight == r_min and r_dict[spotlight] == 0:
                while r_dict[r_sorted[r_sorted_ptr]] < 1:
                    r_sorted_ptr += 1
                    # our updated ptr will be the location of our new r_min

                r_min = r_sorted[r_sorted_ptr]

            pivot += 1

        return pivot
```

For an O(n) method, we basically need a way to be able to check max_left and min_right in O(1).

```python
class Solution:
    def partitionDisjoint(self, nums: List[int]) -> int:
        n = len(nums)
        max_l = [0] * n
        min_r = [0] * n

        max_l[0] = nums[0]
        for i in range(1, n):
            max_l[i] = max(max_l[i - 1], nums[i])

        min_r[-1] = nums[-1]
        for j in range(n - 2, -1, -1):
            min_r[j] = min(min_r[j + 1], nums[j])

        partition = 1
        while max_l[partition - 1] > min_r[partition]:
            partition += 1

        return partition
```