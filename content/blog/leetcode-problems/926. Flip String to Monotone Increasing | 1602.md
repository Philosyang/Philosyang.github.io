---
title: "926. Flip String to Monotone Increasing | 1602"
date: 2025-11-03
tags: ["string", "greedy", "python", "revisit"]
---

I can't think of a correct way.

wrong answer:

```python
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        # 1 -> 0 from beginning
        # 0 -> 1 from end
        # 000110001 (answer should be 2)
        # 000122223 ->
        # 654333210 <-
        # 543454323 nope

        # first `1` and the last `0`?
        # 000110001
        #    x   y
        # 3 zeros after x, 2 ones before y
        # 010110
        #  x   y
        # 2 zeros after x, 3 ones before y
        # 00011000
        #    x   y
        # 3 zeros after x, 2 ones before y

        # wrong answer:
        # 10011111110010111011 (should return 5)
        # x                y
        # x12       34 5   6
        #    ..98765  4 321y
        # 1         23 4   5

        # wrong implementation:

        first_one = s.find("1")
        last_zero = s.rfind("0")

        if first_one == -1 or last_zero == -1:
            return 0

        return min(Counter(s[first_one:])["0"], Counter(s[:last_zero])["1"])
```

O(n) greedy has deeper thoughts but the code is surprisingly light:

```python
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        # general idea:

        # When you see a '1', do you ever need to flip it immediately to keep the prefix monotone increasing? Why or why not?

        # suppose you encounter a '0' after you've already seen some '1's. To keep the prefix monotone, you have two choices—what are they, and what’s the cost of each in terms of `ones` and `flips` so far?

        # result:
        # when you see a '0': flips = min(flips+1, ones)
        # when you see a '1': ones += 1

        flips = 0
        ones = 0

        for c in s:
            if c == "0":
                flips = min(flips + 1, ones)
            else:
                ones += 1

        return flips  # while iterating, flips _always_ keeps track of the **minimum flips** that will make s[0:now] legal
```