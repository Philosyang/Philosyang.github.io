---
title: "739. Daily Temperatures: Monotonic Stack"
date: 2025-08-04
tags: ["neetcode150", "stack", "python"]
---

I initially couldn't think of a better way than a O(nlogn) binary search method (O(nlogn) a list that sorts by (temp, day index) and O(logn) lookup per day).
Peeked on the optimal data stucture to use which was a (monotonic) stack. Time to understand this.

Simply put, a monotonic stack is a stack but you maintain it so that it's kept sorted either asc or desc. This is surprisingly useful on "retrieve the next greater/smaller element" questions.

We want to design our stack according to the question like this: we want to quickly locate _the next day that is hotter than today_. This induces us to construct the stack from the newer days to the older days since we need to know the future.

bottom `[newest, newer, new, ...]` top

We want the nearest day as long as it's hotter, and a stack already solved that question for us, since we LIFO and push from the newer days, the newest day will always be at the bottom.

I asked for a hint after my first code failed to incorporate the date alongside the temps (how are you supposed to calculate the date distance in O(1) per day). We need to keep track of the `(temp, idx)`.

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        result = []
        stack = []  # (temp, date_idx)

        for i in range(n - 1, -1, -1):
            temp = temperatures[i]

            while stack and stack[-1][0] <= temp:
                stack.pop()

            if stack:
                result.append(stack[-1][1] - i)
            else:
                result.append(0)
            stack.append((temp, i))

        return result[::-1]
```

This is optimal O(n) TC SC. We can still make small improvements:

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        result = [0] * n    # prevented the need to flip the result at the end
        stack = []  # we only store idx since temperatures[i] == temp

        for i in range(n - 1, -1, -1):
            while stack and temperatures[stack[-1]] <= temperatures[i]:
                stack.pop()

            result[i] = stack[-1] - i if stack else 0
            stack.append(i)

        return result
```
