---
title: "1774. Closest Dessert Cost | 1702"
date: 2025-12-01
tags: ["array", "backtracking", "python", "revisit"]
---

I need to revisit this some time. I spent a long time on the bug and I still think my code is only passable.

```python
class Solution:
    def closestCost(
        self, baseCosts: List[int], toppingCosts: List[int], target: int
    ) -> int:
        # intuition
        # not straightforward but we can break things down
        # base only
        # base + 1x topping A
        # base + 2x topping A
        # base + 1x topping A + 1x topping B
        # base + 1x topping A + 2x topping B
        # ...
        # we can append toppingCosts with 2x each topping
        # and keep toppingCosts sorted
        # then for each base, binary search
        # this will not work because we cannot have both 1xstrawberry and 2xstrawberry
        # ... brute force? brute force works but it's not what we wanted to practice
        # backtracking huh

        closest_possible_cost = baseCosts[0]
        n, m = len(baseCosts), len(toppingCosts)

        def update_best(candidate) -> bool:
            nonlocal closest_possible_cost
            # True means meaningful update
            # False means way overblown, no need to continue
            # print(candidate, closest_possible_cost)

            candidate_diff = abs(candidate - target)
            running_diff = abs(closest_possible_cost - target)
            if candidate_diff < running_diff or (
                candidate_diff == running_diff and candidate < closest_possible_cost
            ):
                closest_possible_cost = candidate
                return True
            elif candidate >= closest_possible_cost >= target:
                return False
            return True

        def dfs(current_cost: int, current_topping_idx: int) -> None:
            # print(current_cost, current_topping_idx)
            # update & exit check
            # if current_topping_idx >= m or not update_best(current_cost):
            #     return
            # above is a SERIOUS BUG!!!
            if not update_best(current_cost) or current_topping_idx >= m:
                return

            for number_of_current_topping in range(3):
                dfs(
                    current_cost
                    + number_of_current_topping * toppingCosts[current_topping_idx],
                    current_topping_idx + 1,
                )

            return

        for i in range(n):
            update_best(baseCosts[i])
            if closest_possible_cost == target:
                return target
            dfs(baseCosts[i], 0)

        return closest_possible_cost
```
