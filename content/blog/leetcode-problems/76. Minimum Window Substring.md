---
title: "76. Minimum Window Substring"
date: 2025-10-27
tags: ["neetcode150", "sliding-window", "python", "revisit"]
---

Don't know why it's labelled as a hard, but good sliding window problem.

Improvable items (thanks chatgpt):  
1. Avoid O(Σ) checks each step. satisfactory() scans 52 slots every time the window changes. Keep a running count of how many required characters are currently satisfied will make each step O(1).
1. Use direct ASCII buckets or Counter. Arrays of size 128 (or 256) avoid the custom idx and handle both cases naturally. It’s also clearer than ord>=97 tricks. (Or use collections.Counter.)

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        # print(ord("A"))  # 65
        # print(ord("a"))  # 97

        # [A, B, ...., Y, Z, a, b, ..., y, z]
        s_store = [0] * 26 * 2
        t_store = [0] * 26 * 2

        def idx(c):
            o = ord(c)
            if o >= 97:
                return o - 97 + 26
            return o - 65

        # print(idx("a"))  # 26
        # print(idx("b"))  # 27
        # print(idx("A"))  # 0
        # print(idx("B"))  # 1

        # t str into t_store
        for c in t:
            t_store[idx(c)] += 1

        def satisfactory() -> bool:
            for i in range(52):
                if t_store[i] > s_store[i]:
                    return False
            return True

        # let's go sliding
        l = 0
        min_window = [10**6, -1, -1]  # [length, l, r (both inclusive)]

        for r, c in enumerate(s):
            # expand r till satisfactory
            # shrink l till non satis
            s_store[idx(c)] += 1

            while satisfactory() and l <= r:
                if r - l + 1 < min_window[0]:
                    min_window = [r - l + 1, l, r]

                s_store[idx(s[l])] -= 1
                l += 1

        return s[min_window[1] : min_window[2] + 1] if min_window[1] > -1 else ""
```
