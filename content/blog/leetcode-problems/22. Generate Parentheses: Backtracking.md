---
title: "22. Generate Parentheses: Backtracking"
date: 2025-07-23
tags: ["neetcode150", "backtracking", "python"]
---

ref: https://neetcode.io/solutions/generate-parentheses

### general idea
1. we can add `(` only if `opened_n < n`
2. we can add `)` only if `closed_n < closed_n`
3. output is valid iff `opened_n == closed_n == n`

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack = []
        result = []

        def bt(opened_n, closed_n):
            if opened_n == closed_n == n:
                result.append("".join(stack))
                return

            if opened_n < n:
                stack.append("(")
                bt(opened_n + 1, closed_n)
                stack.pop()

            if closed_n < opened_n:
                stack.append(")")
                bt(opened_n, closed_n + 1)
                stack.pop()

        bt(0, 0)

        return result
```

I need a write on mastering backtracking.

---

Addendum (2025-08-02):

I tried to tackle this again after a week - I stumbled a bit, but this new solution is clean, too.

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        result = []

        def bt(opened, closed, t):
            # 1. if max reached, combine then result
            # 2. if we can still open
            # 3. if we can still close
            if opened == closed == n:
                result.append("".join(t))
                return

            if opened < n:
                t.append("(")
                bt(opened + 1, closed, t)
                t.pop()

            if closed < opened:
                t.append(")")
                bt(opened, closed + 1, t)
                t.pop()

        bt(0, 0, [])

        return result
```