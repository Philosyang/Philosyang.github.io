---
title: "[not solved] 3040. Maximum Number of Operations With the Same Score II | 1709"
date: 2025-12-15
tags: ["dynamic-programming", "python"]
---

**Why is this thing 1709?**

First version is good but TLEs, I think it's because I am copying new lists every time:

```python
class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        # intuition: backtrack?

        def bt(ops: int, score: int, arr: List[int]) -> int:
            # print(ops, score, arr)
            if len(arr) < 2:
                return ops

            first_two = ops
            last_two = ops
            first_last = ops

            if arr[0] + arr[1] == score:
                first_two = bt(ops + 1, score, arr[2:])
            if arr[-1] + arr[-2] == score:
                last_two = bt(ops + 1, score, arr[:-2])
            if arr[0] + arr[-1] == score:
                first_last = bt(ops + 1, score, arr[1:-1])

            return max([first_two, last_two, first_last])

        if len(nums) < 2:
            return 0

        ft = bt(1, nums[0] + nums[1], nums[2:])
        lt = bt(1, nums[-1] + nums[-2], nums[:-2])
        fl = bt(1, nums[0] + nums[-1], nums[1:-1])
        # print(ft, lt, fl)

        return max([ft, lt, fl])
```

let's switch to indexes and see:

```python
class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        # intuition: backtracking with l, r pointers

        # you can infer remaining_length from l and r but
        def bt(
            num_of_ops: int, score: int, remaining_length: int, l: int, r: int
        ) -> int:
            nonlocal nums

            if remaining_length < 2:
                return num_of_ops

            first_two = num_of_ops
            last_two = num_of_ops
            first_last = num_of_ops

            if nums[l] + nums[l + 1] == score:
                first_two = bt(num_of_ops + 1, score, remaining_length - 2, l + 2, r)
            if nums[r] + nums[r - 1] == score:
                last_two = bt(num_of_ops + 1, score, remaining_length - 2, l, r - 2)
            if nums[l] + nums[r] == score:
                first_last = bt(
                    num_of_ops + 1, score, remaining_length - 2, l + 1, r - 1
                )

            return max(first_two, last_two, first_last)

        n = len(nums)
        return max(
            bt(1, nums[0] + nums[1], n - 2, 2, n - 1),
            bt(1, nums[-1] + nums[-2], n - 2, 0, n - 3),
            bt(1, nums[0] + nums[-1], n - 2, 1, n - 2),
        )
```

It still TLEs.

Because the runtime is O(3^(n/2)).

DP is needed for scenarios like this:
**given a fixed score**: `dp[l][r]` returns the best possible `num_of_ops` from here till the end.

This saves time because:
i first remove first two then last two, vs i first remove last two then first two, reaches the same solution.

"""  
Without memoization, the recursion is a tree:  
each state can branch up to 3 ways  
so naive worst-case looks like about 3^(n/2) (exponential)

With memoization (fixed score):  
each (l, r) state is computed once  
number of possible (l, r) pairs is about n*(n+1)/2 → O(n²)  
each state does constant work (up to 3 checks/transitions)

So per score: O(n²) time, O(n²) memory.  
With 3 scores: still O(n²) overall (just 3×).  
"""

```python
# tbd
```