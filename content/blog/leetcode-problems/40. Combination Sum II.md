---
title: "40. Combination Sum II"
date: 2026-02-17
tags: ["neetcode150", "backtracking", "python"]
---

Stumbled on effecient dedupe instead of the backtracking part.

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        n = len(candidates)
        candidates.sort()
        result = []

        def bt(ans: List[int], running_sum: int, start_index: int) -> None:
            if running_sum == target:
                result.append(ans[:])
                return

            for i in range(start_index, n):
                candidate = candidates[i]
                if i > start_index and candidate == candidates[i - 1]:  # skip duplicates within the same recursive layer
                    continue
                if running_sum + candidate > target:    # early prune
                    break
                ans.append(candidate)
                bt(ans, running_sum + candidate, i + 1)
                ans.pop()

            return

        bt([], 0, 0)

        return result
```