---
title: "1864. Minimum Number of Swaps to Make the Binary String Alternating | 1601"
date: 2025-11-01
tags: ["neetcode150", "string", "greedy", "python"]
---

Happy November!

---

Passing version:

```python
class Solution:
    def minSwaps(self, s: str) -> int:
        n = len(s)
        swap = 0
        cnt = {"0": 0, "1": 0}
        for c in s:
            cnt[c] += 1

        if abs(cnt["0"] - cnt["1"]) > 1:
            return -1

        # there're actually only several possibilities
        # for even length
        # 111000 -> to 010... requires [x] changes, to 101 requires [n - x] changes, answer is min(these two)/2

        # for odd length, we need to focus all
        # 01011-> more 1s than 0s -> must be 10101
        # 11001
        # 10101

        if n % 2:  # odd
            if cnt["1"] > cnt["0"]:
                for idx, c in enumerate(s):
                    if (idx % 2 == 0 and c != "1") or (idx % 2 == 1 and c != "0"):
                        swap += 1
            else:
                for idx, c in enumerate(s):
                    if (idx % 2 == 0 and c != "0") or (idx % 2 == 1 and c != "1"):
                        swap += 1
        else:  # even
            swap_0 = 0  # swaps needed for 010...
            for idx, c in enumerate(s):
                if (idx % 2 == 0 and c != "0") or (idx % 2 == 1 and c != "1"):
                    swap_0 += 1
            swap = min(swap_0, n - swap_0)

        return swap // 2
```

cleaner version with a same big O:

```python
class Solution:
    def minSwaps(self, s: str) -> int:
        n = len(s)
        changes = 0
        cnt = Counter(s)

        if abs(cnt["0"] - cnt["1"]) > 1:
            return -1

        if n % 2:  # odd
            if cnt["1"] > cnt["0"]:  # 101... only
                for idx, c in enumerate(s):
                    if (idx % 2 == 0 and c != "1") or (idx % 2 == 1 and c != "0"):
                        changes += 1
            else:  # 010... only
                for idx, c in enumerate(s):
                    if (idx % 2 == 0 and c != "0") or (idx % 2 == 1 and c != "1"):
                        changes += 1
        else:  # even
            changes_0 = 0  # changes needed for 010..., n - change_0 is for 101...
            for idx, c in enumerate(s):
                if (idx % 2 == 0 and c != "0") or (idx % 2 == 1 and c != "1"):
                    changes_0 += 1
            changes = min(changes_0, n - changes_0)

        return changes // 2
```

llm version - same runtime, but easier branching:

```python
class Solution:
    def minSwaps(self, s: str) -> int:
        n0 = s.count('0')
        n1 = len(s) - n0
        if abs(n0 - n1) > 1:
            return -1

        # mismatches if pattern is 0101...
        mis_start0 = sum(c != ('0' if i % 2 == 0 else '1') for i, c in enumerate(s))
        # mismatches if pattern is 1010...
        mis_start1 = len(s) - mis_start0  # complementary in even/odd positions

        if n0 == n1:
            return min(mis_start0, mis_start1) // 2
        elif n0 > n1:  # must start with '0'
            return mis_start0 // 2
        else:         # must start with '1'
            return mis_start1 // 2
```