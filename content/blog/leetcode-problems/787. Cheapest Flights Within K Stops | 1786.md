---
title: "787. Cheapest Flights Within K Stops | 1786"
date: 2025-11-16
tags: ["graph", "heap", "python", "revisit"]
---

One of the interview questions I failed before because I used DFS without proper memoization.

wrong dijkstra:

```python
class Solution:
    def findCheapestPrice(
        self, n: int, flights: List[List[int]], src: int, dst: int, k: int
    ) -> int:
        # dijkstra with k stop restrictions

        # construct graph
        graph = {}  # source: [[distance0, destination0], [distance1, destination1]]
        for source, destination, distance in flights:
            if graph.get(source, -1) == -1:
                graph[source] = [[distance, destination]]
            else:
                graph[source].append([distance, destination])
            if graph.get(destination, -1) == -1:
                graph[destination] = []

        # dijkstra init
        dist = {k: float("inf") for k in graph.keys()}
        parent = {k: None for k in graph.keys()}
        pq = [(0, src, -1)]  # distance, location, stop count
        visited = set()

        while pq:
            cur_dist, cur_loc, cur_stop_count = heapq.heappop(pq)

            if cur_loc in visited or cur_stop_count > k:  # k-stop constraint
                continue
            visited.add(cur_loc)

            for child_dist, child_loc in graph[cur_loc]:
                possible_better_dist = cur_dist + child_dist
                if possible_better_dist < dist[child_loc]:  # cheaper price
                    dist[child_loc] = possible_better_dist
                    parent[child_loc] = cur_loc
                    heapq.heappush(
                        pq, (possible_better_dist, child_loc, cur_stop_count + 1)
                    )

        return -1 if dist[dst] > 10**9 else dist[dst]
```

fixed version that sticks with dijkstra:

```python
class Solution:
    def findCheapestPrice(
        self, n: int, flights: List[List[int]], src: int, dst: int, k: int
    ) -> int:
        # dijkstra with k stop restrictions

        # construct graph
        # graph = {}  # source: [[distance0, destination0], [distance1, destination1]]
        # for source, destination, distance in flights:
        #     if graph.get(source, -1) == -1:
        #         graph[source] = [[distance, destination]]
        #     else:
        #         graph[source].append([distance, destination])
        #     if graph.get(destination, -1) == -1:
        #         graph[destination] = []

        # the above does not work because there are cities that have no flights
        graph = {i: [] for i in range(n)}
        for source, destination, distance in flights:
            graph[source].append([distance, destination])

        # dijkstra variant init
        # dist[node][stops_used] = best cost to reach node using exactly stops_used edges
        dist = {key: [float("inf")] * (k + 2) for key in graph.keys()}
        # parent = {k: None for k in graph.keys()}
        pq = [(0, src, 0)]  # distance, location, flight count

        while pq:
            cur_dist, cur_loc, cur_flight_count = heapq.heappop(pq)

            if cur_flight_count > k + 1:
                continue

            if cur_loc == dst:
                return cur_dist  # min heap principles

            if cur_dist > dist[cur_loc][cur_flight_count]:
                continue

            if cur_flight_count == k + 1:
                continue

            for child_dist, child_loc in graph[cur_loc]:
                possible_better_dist = cur_dist + child_dist
                new_flight_count = cur_flight_count + 1
                if (
                    possible_better_dist < dist[child_loc][new_flight_count]
                ):  # cheaper price
                    dist[child_loc][new_flight_count] = possible_better_dist
                    heapq.heappush(
                        pq, (possible_better_dist, child_loc, new_flight_count)
                    )

        return -1
```