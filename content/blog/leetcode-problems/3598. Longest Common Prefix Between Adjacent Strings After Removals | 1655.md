---
title: "3598. Longest Common Prefix Between Adjacent Strings After Removals | 1655"
date: 2025-11-10
tags: ["array", "string", "greedy", "python"]
---

Feels so good when runtime beats 98.90%

```python
class Solution:
    def longestCommonPrefix(self, words: List[str]) -> List[int]:
        # first pass  x record longest length and location(s) between i   and i+1
        # second pass y record longest length and location(s) between i-1 and i+1

        #  ["jump","run","run","jump","run"]
        # x:  0,     3,    0,    0
        # y:         0,    0,    3

        #   ["hi", "hihi", "hi", "hihi", "hi", "hi"]
        # x:  0,     0,     0,     0,     2
        # y:         2,     4,     2,     0

        # when we remove i
        # x will be destroyed
        # y will be established

        # therefore we need to keep track of the best and the second best x
        # if multiple bests, output is constant [max(3, y[i]), max(3, y[i]), max(3, y[i]), ...]
        # if only one best, output is similar to [3,0,0,3,3] where 0 is the second best

        # helper: given two words, return prefix length
        def prefixLength(word_a: str, word_b: str) -> int:
            n = min(len(word_a), len(word_b))
            result = 0
            while result < n and word_a[result] == word_b[result]:
                result += 1
            return result

        words_len = len(words)
        best_x, second_best_x = 0, 0
        best_x_idx, second_best_x_idx = [], []
        y = [0] * words_len

        # construct x
        for i in range(words_len - 1):
            x = prefixLength(words[i], words[i + 1])
            if x > best_x:
                second_best_x = best_x
                second_best_x_idx = best_x_idx
                best_x = x
                best_x_idx = [i]
            elif x == best_x:
                best_x_idx.append(i)
            elif x > second_best_x:
                second_best_x = x
                second_best_x_idx = [i]
            elif x == second_best_x:
                second_best_x_idx.append(i)

        # construct y
        for i in range(1, words_len - 1):
            y[i] = prefixLength(words[i - 1], words[i + 1])

        # construct result
        result = [0] * words_len

        if not best_x:
            for i in range(words_len):
                y_i = y[i]
                if y_i > 0:
                    result[i] = y_i
        elif len(best_x_idx) == 1:
            for i in range(words_len):
                if i == best_x_idx[0] or i == best_x_idx[0] + 1:
                    result[i] = max(second_best_x, y[i])
                else:
                    result[i] = max(best_x, y[i])
        else:  # lots of best_x, most straightforward
            for i in range(words_len):
                result[i] = max(best_x, y[i])

        return result
```