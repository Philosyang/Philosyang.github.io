---
title: "424. Longest Repeating Character Replacement"
date: 2025-10-25
tags: ["neetcode150", "sliding-window", "python"]
---

This is such a beautiful sliding window problem.  
I initially stuck on a O(n**2) sliding solution like

```python
# "AABABBA", 2
#  A
#  AAAAA
#    B
#    BBBBB
#     A
#     AAAA
#      B
#      BBB
#        A
```

where we start over after each try on the next different letter.  
The key to this problem is to find the defining rule of this window.

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        counts = [0] * 26

        def idx(c):
            return ord(c) - ord("A")

        l = 0
        majority = 0  # number of occurance of the most common char within window
        longest = 0

        # rule: majority + k >= window_size

        for r, c in enumerate(s):
            i = idx(c)
            counts[i] += 1
            majority = max(majority, counts[i])

            while majority + k < r - l + 1:
                counts[idx(s[l])] -= 1
                l += 1
                # majority = max(counts)    # why can we omit this? btw this is O(26n)

            longest = max(longest, r - l + 1)

        return longest
```

<details><summary>follow-up: why can we keep a stale `majority`?</summary>
We maintain window_size - majority <= k using a non-decreasing upper bound on the window’s max frequency. This can only make us shrink no more than necessary, never less than necessary in the long run; since majority only increases as r advances, any “too-large” window we kept will become legitimately valid soon (or be forced to shrink later), so the recorded longest remains correct.
</details>