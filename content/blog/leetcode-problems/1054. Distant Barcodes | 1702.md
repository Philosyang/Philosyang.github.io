---
title: "1054. Distant Barcodes | 1702"
date: 2025-11-30
tags: ["array", "greedy", "heap", "python"]
---

I like greed and I like priority queue.

```python
class Solution:
    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:
        # intuition
        # store barcodes in a dict
        # basically iter dict until exhaustion

        # e.g. {1: 3,
        #       2: 4}
        # we MUST put 2 at the beginning, thus intuition fails

        # we will not fail if we always try to put the most abundant number
        # e.g. 1: 3, 2: 5, 3: 4, 4: 3
        # 2, 3, 2, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4
        # need a way to keep track and skip the last barcode

        pq = [(-count, barcode) for barcode, count in Counter(barcodes).items()]
        heapq.heapify(pq)  # heapify first before pop
        prev_barcode = -1
        result = []

        while pq:
            neg_count, barcode = heapq.heappop(pq)

            if barcode == prev_barcode:  # pq is guaranteed to have items
                pending_push = (neg_count, barcode)
                neg_count, barcode = heapq.heappop(pq)
                heapq.heappush(pq, pending_push)

            prev_barcode = barcode

            result.append(barcode)
            if neg_count < -1:  # only push back if still contains barcode
                heapq.heappush(pq, (neg_count + 1, barcode))

        return result
```