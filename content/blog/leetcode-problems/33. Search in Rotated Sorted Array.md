---
title: "33. Search in Rotated Sorted Array"
date: 2025-10-21
tags: ["neetcode150", "binary-search", "python"]
---

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        n = len(nums)

        # 1. find pivot (nums[0])
        l = 0
        r = n - 1

        while l < r:
            m = (l + r) // 2
            # [4,5,6,7,0,1,2] nums[m] > nums[r]
            # [5,6,7,0,1,2,4] nums[m] < nums[r]
            # why compare nums[m] and nums[r], why do we ignore nums[l]?
            # "nums[r] anchors the “true” end of the sorted array, whereas nums[l] can start anywhere depending on the rotation"
            # good enough for interviews
            if nums[m] > nums[r]:
                l = m + 1
            else:
                r = m
            # print(l, r, nums[l])

        pivot = l

        # 2. bisect from pivot (typical binary search)
        l = 0
        r = n - 1

        while l <= r:
            # [4,5,6,7,0,1,2]
            #  l     m p   r
            # the Real `m` should be (m + pivot) % n

            # [4,5,6,7,0,1,2]
            #  l           r
            #  R                (3 + 4) % 7 = 0

            # [5,6,7,0,1,2,4]
            #  l     m     r
            #        p
            #              R    (3 + 3) % 7 = 6

            m = (l + r) // 2
            real = (m + pivot) % n

            # typical binary search
            if nums[real] == target:
                return real
            elif nums[real] < target:
                l = m + 1
            else:
                r = m - 1

        return -1
```